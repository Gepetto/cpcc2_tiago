#pragma once

// STL
#include <atomic>
#include <string>
#include <thread>
#include <vector>
// cpcc2_tiago
#include <cpcc2_tiago/locked.hpp>
#include <cpcc2_tiago/model_builder.hpp>
#include <cpcc2_tiago/tiago_OCP.hpp>
#include <cpcc2_tiago/utils.hpp>
// auto-generated by generate_parameter_library
#include <cpcc2_tiago_parameters.hpp>

namespace cpcc2_tiago {

class ParallelCrocSolver {
 private:
  pin::Model model_;
  pin::Data data_;

  std::thread thread_;
  std::atomic<bool> running_ = true;
  std::atomic<double> current_time_ = 0.;

  Locked<Eigen::Vector3d> target_;
  Locked<Eigen::VectorXd> x_meas_;
  Locked<Eigen::VectorXd> us_;
  Locked<Eigen::VectorXd> xs0_;
  Locked<Eigen::VectorXd> xs1_;
  Locked<Eigen::MatrixXd> Ks_;

  tiago_OCP::OCP OCP_tiago_;

  std::vector<std::string> joints_names_;

  CircularVector<20> solving_time_vector_;
  CircularVector<20> solver_freq_vector_;

  double last_current_time_ = 0;
  double OCP_time_step_ = 0;
  double OCP_solver_frequency_ = 0;

  pin::FrameIndex lh_id_ = -1;

  int OCP_horizon_length_ = 0;
  int OCP_solver_iterations_ = 0;
  int n_joints_ = 0;

  /// @brief Read parameters
  void read_params();

  /// @brief Resize vectors
  void resize_vectors();

  /// @brief Create the shared memory
  void init_shared_memory();

  /// @brief Read x from the shared memory
  /// @return the state as a VectorXd
  Eigen::VectorXd read_controller_x();

  /// @brief Read target from the shared memory
  /// @return the target as a Vector3d
  Eigen::Vector3d read_controller_target();

  /// @brief Send the result of the controller to the shared memory
  void send_controller_result(const Eigen::VectorXd& us,
                              const Eigen::VectorXd& xs0,
                              const Eigen::VectorXd& xs1,
                              const Eigen::MatrixXd& Ks);

  void update();
  void wait();

 public:
  ParallelCrocSolver() = default;
  ~ParallelCrocSolver();

  void init_model(const std::string& urdf_xml);
  void start_thread();

  using results_type =
      std::tuple<Unlocked<Eigen::VectorXd>, Unlocked<Eigen::VectorXd>,
                 Unlocked<Eigen::VectorXd>, Unlocked<Eigen::MatrixXd>>;

  inline void set_current_time(double time) { current_time_ = time; }
  inline void set_target(const Eigen::Vector3d& target) { target_ = target; }
  inline void set_x_meas(const Eigen::VectorXd& x_meas) { x_meas_ = x_meas; }
  inline results_type get_results() {
    auto us = us_.unlock();
    auto xs0 = xs0_.unlock();
    auto xs1 = xs1_.unlock();
    auto Ks = Ks_.unlock();
    return results_type{std::move(us), std::move(xs0), std::move(xs1),
                        std::move(Ks)};
  }
};

}  // namespace cpcc2_tiago
