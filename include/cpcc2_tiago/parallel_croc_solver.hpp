#ifndef PARALLEL_CROC_SOLVER_HPP
#define PARALLEL_CROC_SOLVER_HPP

#include <boost/interprocess/containers/vector.hpp>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/sync/interprocess_mutex.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/thread/thread_time.hpp>

#include "cpcc2_tiago/model_builder.hpp"
#include "cpcc2_tiago/tiago_OCP.hpp"

// auto-generated by generate_parameter_library
#include "cpcc2_tiago_parameters.hpp"

// circular vector to store values over time and calculate the rolling mean
struct CircularVector {
  Eigen::VectorXd vector;

  CircularVector(int size) : vector(size) {
    vector.setZero(); // Initialiser le vecteur avec des z√©ros
  }

  void circular_append(double new_value) {
    Eigen::VectorXd shifted_vector(vector.size());
    for (int i = 0; i < vector.size() - 1; ++i) {
      shifted_vector(i) = vector(i + 1);
    }
    shifted_vector(vector.size() - 1) = new_value;
    vector = shifted_vector;
  }
};

cpcc2_tiago::Params params_; // load parmeters from yaml file

boost::interprocess::named_mutex mutex_{boost::interprocess::open_or_create,
                                        "crocoddyl_mutex"};

typedef boost::interprocess::allocator<
    double, boost::interprocess::managed_shared_memory::segment_manager>
    shm_allocator;

// Alias a vector that uses the previous STL-like allocator
typedef boost::interprocess::vector<double, shm_allocator> shared_vector;

boost::interprocess::managed_shared_memory crocoddyl_shm_;

Model model_;
Data data_;

FrameIndex lh_id_;

tiago_OCP::OCP OCP_tiago_;

int OCP_horizon_length_;
double OCP_time_step_;
int OCP_solver_iterations_;
double OCP_solver_frequency_;

std::vector<std::string> joints_names_;
int n_joints_;

Eigen::VectorXd x_meas_;
shared_vector *x_meas_shm_;

Eigen::VectorXd us_;
shared_vector *us_shm_;

Eigen::VectorXd xs0_;
shared_vector *xs0_shm_;
Eigen::VectorXd xs1_;
shared_vector *xs1_shm_;

Eigen::MatrixXd Ks_;
shared_vector *Ks_shm_;

Eigen::Vector3d target_;
shared_vector *target_shm_;

bool *solver_started_shm_;
bool *is_first_update_done_shm_;
bool is_first_update_done_ = false;

bool *start_sending_cmd_shm_;
bool start_sending_cmd_ = false;

double *current_t_shm_;

double current_t_;
double start_solving_time_;
double last_solving_time_;
double solving_time_;
double solver_freq_;
double diff_;

CircularVector solving_time_vector_(20);
CircularVector solver_freq_vector_(20);

/// @brief Read parameters
void read_params();

/// @brief Resize vectors
void resize_vectors();

/// @brief Create the shared memory
void init_shared_memory();

/// @brief get the ROS time in order to be synchronized
/// @return the ROS time
double get_ROS_time();

/// @brief Read x from the shared memory
/// @return the state as a VectorXd
Eigen::VectorXd read_controller_x();

/// @brief Read target from the shared memory
/// @return the target as a Vector3d
Eigen::Vector3d read_controller_target();

/// @brief Send the result of the controller to the shared memory
void send_controller_result(Eigen::VectorXd us, Eigen::VectorXd xs0,
                            Eigen::VectorXd xs1, Eigen::MatrixXd Ks);

#endif // PARALLEL_CROC_SOLVER_HPP