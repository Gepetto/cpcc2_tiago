#pragma once

// boost
#include <boost/interprocess/containers/vector.hpp>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/sync/interprocess_mutex.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/thread/thread_time.hpp>
// cpcc2_tiago
#include <cpcc2_tiago/model_builder.hpp>
#include <cpcc2_tiago/tiago_OCP.hpp>
#include <cpcc2_tiago/utils.hpp>
// auto-generated by generate_parameter_library
#include <cpcc2_tiago_parameters.hpp>

namespace cpcc2_tiago {

class ParallelCrocSolver {
 private:
  cpcc2_tiago::Params params_;  // load parmeters from yaml file

  pin::Model model_;
  pin::Data data_;

  tiago_OCP::OCP OCP_tiago_;

  std::vector<std::string> joints_names_;

  Eigen::VectorXd x_meas_;
  Eigen::VectorXd us_;
  Eigen::VectorXd xs0_;
  Eigen::VectorXd xs1_;
  Eigen::MatrixXd Ks_;
  Eigen::Vector3d target_;

  CircularVector solving_time_vector_{20};
  CircularVector solver_freq_vector_{20};

  boost::interprocess::managed_shared_memory crocoddyl_shm_;

  boost::interprocess::named_mutex mutex_{boost::interprocess::open_or_create,
                                          mutex_name.c_str()};

  shared_vector *x_meas_shm_;
  shared_vector *us_shm_;
  shared_vector *xs0_shm_;
  shared_vector *xs1_shm_;
  shared_vector *Ks_shm_;
  shared_vector *target_shm_;

  shared_string *urdf_xml_;

  bool *solver_started_shm_;
  bool *is_first_update_done_shm_;
  bool *start_sending_cmd_shm_;
  bool *urdf_xml_sent_;

  double *current_t_shm_;

  double current_t_;
  double start_solving_time_;
  double last_solving_time_;
  double solving_time_;
  double solver_freq_;
  double diff_;
  double OCP_time_step_;
  double OCP_solver_frequency_;

  pin::FrameIndex lh_id_;

  int OCP_horizon_length_;
  int OCP_solver_iterations_;
  int n_joints_;

  bool is_first_update_done_ = false;

  /// @brief Read parameters
  void read_params();

  /// @brief Resize vectors
  void resize_vectors();

  /// @brief Create the shared memory
  void init_shared_memory();

  /// @brief get the ROS time in order to be synchronized
  /// @return the ROS time
  double get_ROS_time();

  double read_current_t();

  /// @brief Read x from the shared memory
  /// @return the state as a VectorXd
  Eigen::VectorXd read_controller_x();

  /// @brief Read target from the shared memory
  /// @return the target as a Vector3d
  Eigen::Vector3d read_controller_target();

  /// @brief Send the result of the controller to the shared memory
  void send_controller_result(Eigen::VectorXd us, Eigen::VectorXd xs0,
                              Eigen::VectorXd xs1, Eigen::MatrixXd Ks);

 public:
  ParallelCrocSolver();

  void update();
};

}  // namespace cpcc2_tiago
