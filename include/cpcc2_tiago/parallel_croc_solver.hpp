#ifndef PARALLEL_CROC_SOLVER_HPP
#define PARALLEL_CROC_SOLVER_HPP

#include <boost/interprocess/containers/vector.hpp>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/sync/interprocess_mutex.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/thread/thread_time.hpp>

#include "cpcc2_tiago/model_builder.hpp"
#include "cpcc2_tiago/shared_mutex.hpp"
#include "cpcc2_tiago/tiago_OCP.hpp"

// auto-generated by generate_parameter_library
#include "cpcc2_tiago_parameters.hpp"

cpcc2_tiago::Params params_; // load parmeters from yaml file

boost::interprocess::named_mutex mutex_{boost::interprocess::open_or_create,
                                        "crocoddyl_mutex"};

typedef boost::interprocess::allocator<
    double, boost::interprocess::managed_shared_memory::segment_manager>
    shm_allocator;

// Alias a vector that uses the previous STL-like allocator
typedef boost::interprocess::vector<double, shm_allocator> shared_vector;

boost::interprocess::managed_shared_memory crocoddyl_shm_;

Model model_;
Data data_;

FrameIndex lh_id_;

tiago_OCP::OCP OCP_tiago_;

int OCP_horizon_length_;
double OCP_time_step_;
int OCP_solver_iterations_;
double OCP_solver_frequency_;

std::chrono::time_point<std::chrono::high_resolution_clock> start_solving_time_;
std::chrono::time_point<std::chrono::high_resolution_clock> last_solving_time_;
std::chrono::time_point<std::chrono::high_resolution_clock> current_t_;

std::chrono::duration<long, std::nano> diff_;

std::vector<std::string> joints_names_;
int n_joints_;

Eigen::VectorXd x_meas_;
shared_vector *x_meas_shm_;

Eigen::VectorXd us_;
shared_vector *us_shm_;

Eigen::VectorXd xs0_;
shared_vector *xs0_shm_;
Eigen::VectorXd xs1_;
shared_vector *xs1_shm_;

Eigen::MatrixXd Ks_;
shared_vector *Ks_shm_;

Eigen::Vector3d target_;
shared_vector *target_shm_;

bool *solver_started_shm_;
bool *is_first_update_done_shm_;
bool is_first_update_done_ = false;

bool *start_sending_cmd_shm_;
bool start_sending_cmd_ = false;

/// @brief Read parameters
void read_params();

/// @brief Resize vectors
void resize_vectors();

/// @brief Create the shared memory
void init_shared_memory();

/// @brief Read x from the shared memory
Eigen::VectorXd read_controller_x();

/// @brief Read target from the shared memory
Eigen::Vector3d read_controller_target();

/// @brief Send the result of the controller to the shared memory
void send_controller_result(Eigen::VectorXd us, Eigen::VectorXd xs0,
                            Eigen::VectorXd xs1, Eigen::MatrixXd Ks);

#endif // PARALLEL_CROC_SOLVER_HPP