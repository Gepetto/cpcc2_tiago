#ifndef CROCODDYL_CONTROLLER_HPP
#define CROCODDYL_CONTROLLER_HPP

#include <boost/interprocess/containers/vector.hpp>
#include <boost/interprocess/managed_shared_memory.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/sync/interprocess_mutex.hpp>
#include <boost/interprocess/sync/named_mutex.hpp>
#include <boost/thread/thread_time.hpp>

#include "controller_interface/chainable_controller_interface.hpp"
#include "controller_interface/controller_interface.hpp"
#include "controller_interface/helpers.hpp"
#include "cpcc2_tiago/logger_OCP.hpp"
#include "cpcc2_tiago/model_builder.hpp"
#include "cpcc2_tiago/shared_mutex.hpp"
#include "cpcc2_tiago/tiago_OCP.hpp"
#include "cpcc2_tiago/visibility_control.h"
#include "hardware_interface/loaned_command_interface.hpp"
#include "hardware_interface/types/hardware_interface_type_values.hpp"
#include "pinocchio/algorithm/parallel/aba.hpp"
#include "pluginlib/class_list_macros.hpp"
#include "rclcpp/logging.hpp"
#include "rclcpp/subscription.hpp"
#include "rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp"
#include "rclcpp_lifecycle/state.hpp"
#include "realtime_tools/realtime_buffer.h"
#include "std_msgs/msg/float64_multi_array.hpp"

// auto-generated by generate_parameter_library
#include "cpcc2_tiago_parameters.hpp"

namespace cpcc2_tiago {
/// @brief Effort Controller (Higher Level Controller) to set reference
/// interfaces received from Chainable Controller
class CrocoddylController : public controller_interface::ControllerInterface {
 public:
  /// @brief Documentation Inherited
  CPCC2_TIAGO_PUBLIC
  controller_interface::CallbackReturn on_init() override;

  /// @brief Documentation Inherited
  CPCC2_TIAGO_PUBLIC
  controller_interface::InterfaceConfiguration command_interface_configuration()
      const override;

  /// @brief Documentation Inherited
  CPCC2_TIAGO_PUBLIC
  controller_interface::InterfaceConfiguration state_interface_configuration()
      const override;

  /// @brief Documentation Inherited
  CPCC2_TIAGO_PUBLIC
  controller_interface::return_type update(
      const rclcpp::Time &time, const rclcpp::Duration &period) override;

  /**
   * Derived controller have to declare parameters in this method.
   * Error handling does not have to be done. It is done in `on_init`-method of
   * this class.
   */
  void declare_parameters();

  /**
   * Derived controller have to read parameters in this method and set
   * `command_interface_types_` variable. The variable is then used to propagate
   * the command interface configuration to controller manager. The method is
   * called from `on_configure`-method of this class.
   *
   * It is expected that error handling of exceptions is done.
   *
   * \returns controller_interface::CallbackReturn::SUCCESS if parameters are
   * successfully read and their values are allowed,
   * controller_interface::CallbackReturn::ERROR otherwise.
   */

  controller_interface::CallbackReturn read_parameters();

 private:
  struct state {
    Eigen::VectorXd position;
    Eigen::VectorXd velocity;
  };

  std::shared_ptr<ParamListener> param_listener_;
  Params params_;

  boost::interprocess::named_mutex mutex_{boost::interprocess::open_or_create,
                                          "crocoddyl_mutex"};

  // Alias an STL compatible allocator of ints that allocates ints from the
  // managed shared memory segment.  This allocator will allow to place
  // containers in managed shared memory segments
  typedef boost::interprocess::allocator<
      double, boost::interprocess::managed_shared_memory::segment_manager>
      shm_allocator;
  // Alias a vector that uses the previous STL-like allocator
  typedef boost::interprocess::vector<double, shm_allocator> shared_vector;

  boost::interprocess::managed_shared_memory crocoddyl_shm_;

  rclcpp::Subscription<std_msgs::msg::Float64MultiArray>::SharedPtr
      target_subscriber_;

  Model model_;
  Data data_;

  FrameIndex lh_id_;

  rclcpp::Time start_update_time_ = rclcpp::Time(0, 0, RCL_ROS_TIME);
  rclcpp::Time last_update_time_ = rclcpp::Time(0, 0, RCL_ROS_TIME);
  rclcpp::Time current_t_ = rclcpp::Time(0, 0, RCL_ROS_TIME);

  Eigen::VectorXd x_meas_;
  shared_vector *x_meas_shm_;

  Eigen::VectorXd us_;
  shared_vector *us_shm_;

  Eigen::VectorXd xs0_;
  shared_vector *xs0_shm_;
  Eigen::VectorXd xs1_;
  shared_vector *xs1_shm_;

  Eigen::MatrixXd Ks_;
  shared_vector *Ks_shm_;

  shared_vector *target_shm_;

  // is the first crocoddyl controller update done : target set
  bool is_first_update_ = true;
  bool *is_first_update_done_shm_;

  // is the parallel crocoddyl solver started
  bool *solver_started_shm_;
  bool start_updating = false;

  Eigen::Vector3d pos_error_;

  Eigen::Vector3d end_effector_pos_;

  int n_joints_;
  std::vector<std::string> joints_names_;

  bool enable_logging_;
  logger_OCP::logger logger_;
  double logging_frequency_;

  /// @brief all types of state interface, in our case effort, velocity,
  /// position
  std::vector<std::string> state_interface_types_;

  /// @brief Current state at time t, overwritten next timestep
  state current_state_;

  void init_shared_memory();

  void send_solver_x(Eigen::VectorXd x);
  void read_solver_results();

  /// @brief Read the actuators state, eff, vel, pos from the hardware
  /// interface
  void read_state_from_hardware(state &current_state);

  void update_target_from_subscriber(
      const std_msgs::msg::Float64MultiArray::SharedPtr msg);

  /// @brief set the effort command
  /// @param interface_command command_interface to send the command to
  /// @param command_eff vector of the desired torque
  void set_u_command(Eigen::VectorXd command_u);
  void set_x0_command(Eigen::VectorXd command_x);
  void set_x1_command(Eigen::VectorXd command_x);
  void set_K_command(Eigen::MatrixXd comman_K);
};
}  // namespace cpcc2_tiago
#endif
