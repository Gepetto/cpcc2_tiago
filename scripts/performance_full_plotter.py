#!/usr/bin/env python3


"""
This script is used to plot the performance of the cpcc2 controller.
It reads the log files generated by the performance_evaluator.py script and plots the error history,
it is mandatory that the 3 tests have been run with the same target sequence, and are named as follow:
error_history_{suffix}.txt and full_history_{suffix}.csv where suffix is aba, lin or none.
The command to run the performance_evaluator.py script is:
ros2 run cpcc2_tiago performance_full_plotter /path/to/log/dir/
"""

import re
import csv
import matplotlib.pyplot as plt
import matplotlib
import numpy as np
import sys


def plot_error(error_dir_path, file_names):
    plt.figure()
    colors = ["r", "g", "b"]
    titles = ["ABA", "Linear", "None"]
    for i in range(3):
        error_history = []
        targets = []
        elapsed_times = []
        with open(error_dir_path + file_names[i]) as f:
            for line in f.readlines():
                target_match = re.search(r"Target: \[([\d\.-]+), ([\d\.-]+), ([\d\.-]+)\]", line)
                error_match = re.search(r"Error: ([\d\.]+)", line)
                time_match = re.search(r"Elapsed Time: ([\d\.]+)", line)

                target_x = float(target_match.group(1))
                target_y = float(target_match.group(2))
                target_z = float(target_match.group(3))

                # Extraire l'erreur et le temps écoulé
                error = float(error_match.group(1))
                elapsed_time = float(time_match.group(1))

                targets.append((target_x, target_y, target_z))
                error_history.append(error)
                elapsed_times.append(elapsed_time)

        plt.scatter(
            [f"x:{i[0]}\n y:{i[1]}\n z:{i[2]}" for i in targets],
            [e * 1e3 for e in error_history],
            c=colors[i],
        )
        plt.yticks(np.arange(0, 1e3 * max(error_history) + 1, 0.5))
        plt.title("Error history to target, and elapsed time")
        plt.legend(titles)
        plt.xlabel("Target")
        plt.ylabel("Euclidian distance (mm)")
        for i, t in enumerate(targets):
            plt.annotate(
                f"{elapsed_times[i]:.1f}s",
                (i, 1e3 * error_history[i]),
                (i - 0.1, 1e3 * error_history[i] + 0.2),
            )


def parse_log_file(log_file_path):
    with open(log_file_path) as f:
        reader = csv.reader(f)
        rows_nb = sum(1 for row in reader)
        f.seek(0)
        times = []
        targets = np.empty((rows_nb, 3))
        errors = np.empty((rows_nb, 3))
        croc_torques = np.empty((rows_nb, 5))
        ric_torques = np.empty((rows_nb, 5))
        real_torques = np.empty((rows_nb, 5))
        ddqs = np.empty((rows_nb, 5))

        for i, row in zip(range(rows_nb), reader):
            times.append(float(row[0]))
            targets[i] = [float(x) for x in row[1:4]]
            errors[i] = [float(x) for x in row[4:7]]
            croc_torques[i] = [float(x) for x in row[7:12]]
            ric_torques[i] = [float(x) for x in row[12:17]]
            real_torques[i] = [float(x) for x in row[17:22]]
            ddqs[i] = [float(x) for x in row[22::]]

    return times, targets, errors, croc_torques, ric_torques, real_torques, ddqs


def calculate_jerk(ddqs, times):
    dt = np.diff(times)
    jerk = np.divide(np.diff(ddqs, axis=0), np.array([dt for _ in range(5)]).T)
    return jerk


def main():
    txt_file_names = [
        "error_history_aba.txt",
        "error_history_lin.txt",
        "error_history_none.txt",
    ]
    csv_file_names = [
        "full_history_aba.csv",
        "full_history_lin.csv",
        "full_history_none.csv",
    ]

    matplotlib.rcParams.update({"font.size": 17})

    plot_error(sys.argv[1], txt_file_names)

    titles = ["ABA", "Linear", "None"]

    jerk_layout = [["aba_jerk"], ["lin_jerk"], ["none_jerk"]]

    fig_jerk, axd_jerk = plt.subplot_mosaic(jerk_layout)

    pos_layout = [["x_pos"], ["y_pos"], ["z_pos"]]
    axes = ["x", "y", "z"]
    fig_pos, axd_pos = plt.subplot_mosaic(pos_layout)

    for i in range(3):
        (
            times,
            targets,
            errors,
            croc_torques,
            ric_torques,
            real_torques,
            ddqs,
        ) = parse_log_file(sys.argv[1] + csv_file_names[i])
        jerks = calculate_jerk(ddqs, times)

        # jerk plot
        axd_jerk[jerk_layout[i][0]].plot(times[:-1], [jerks[i, :] for i in range(len(jerks))])
        axd_jerk[jerk_layout[i][0]].ticklabel_format(axis="y", style="sci", scilimits=(0, 0))
        fig_jerk.legend(
            ["Act 1", "Act 2", "Act 3", "Act 4", "Act 5"],
            loc=(0.25, 0),
            ncol=5,
        )
        axd_jerk[jerk_layout[i][0]].set_xlabel("Time (s)")
        axd_jerk[jerk_layout[i][0]].set_ylabel("Jerk (rad/s³)")
        axd_jerk[jerk_layout[i][0]].set_title(f"Jerk history {titles[i]}")

        # pos plot
        axd_pos[pos_layout[0][0]].plot(times, (np.array(targets)[:, 0] - np.array(errors)[:, 0]))

        axd_pos[pos_layout[0][0]].set_xlabel("Time (s)")
        axd_pos[pos_layout[0][0]].set_ylabel("Position (m)")
        axd_pos[pos_layout[0][0]].set_title(f"Position history and target, {axes[0]} axis")

        axd_pos[pos_layout[1][0]].plot(times, (np.array(targets)[:, 1] - np.array(errors)[:, 1]))
        axd_pos[pos_layout[1][0]].set_xlabel("Time (s)")
        axd_pos[pos_layout[1][0]].set_ylabel("Position (m)")
        axd_pos[pos_layout[1][0]].set_title(f"Position history and target, {axes[1]} axis")

        axd_pos[pos_layout[2][0]].plot(times, (np.array(targets)[:, 2] - np.array(errors)[:, 2]))
        axd_pos[pos_layout[2][0]].set_xlabel("Time (s)")
        axd_pos[pos_layout[2][0]].set_ylabel("Position (m)")
        axd_pos[pos_layout[2][0]].set_title(f"Position history and target, {axes[2]} axis")

        layout = [
            ["croc_torque", "ric_torque", "real_torques"],
            ["acceleration", "jerk", "errors"],
        ]

        fig, axd = plt.subplot_mosaic(layout)

        axd["croc_torque"].plot(times, [croc_torques[i, :] for i in range(len(croc_torques))])
        axd["croc_torque"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["croc_torque"].set_xlabel("Time (s)")
        axd["croc_torque"].set_ylabel("Torque (Nm)")
        axd["croc_torque"].set_title(f"Crocoddyl torque history {titles[i]}")

        axd["ric_torque"].plot(times, [ric_torques[i, :] for i in range(len(ric_torques))])
        axd["ric_torque"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["ric_torque"].set_xlabel("Time (s)")
        axd["ric_torque"].set_ylabel("Torque (Nm)")
        axd["ric_torque"].set_title(f"Ricatti torque history {titles[i]}")

        axd["real_torques"].plot(times, [real_torques[i, :] for i in range(len(real_torques))])
        axd["real_torques"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["real_torques"].set_xlabel("Time (s)")
        axd["real_torques"].set_ylabel("Torque (Nm)")
        axd["real_torques"].set_title(f"Real torque history {titles[i]}")

        axd["acceleration"].plot(times, [ddqs[i, :] for i in range(len(ddqs))])
        axd["acceleration"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["acceleration"].set_xlabel("Time (s)")
        axd["acceleration"].set_ylabel("Acceleration (rad/s²)")
        axd["acceleration"].set_title(f"Acceleration history {titles[i]}")

        axd["jerk"].plot(times[:-1], [jerks[i, :] for i in range(len(jerks))])
        axd["jerk"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["jerk"].set_xlabel("Time (s)")
        axd["jerk"].set_ylabel("Jerk (rad/s³)")
        axd["jerk"].set_title(f"Jerk history {titles[i]}")

        axd["errors"].plot(times, [errors[i, :] for i in range(len(errors))])
        axd["errors"].legend(["Motor 1", "Motor 2", "Motor 3", "Motor 4", "Motor 5"])
        axd["errors"].set_xlabel("Time (s)")
        axd["errors"].set_ylabel("Errors (m)")
        axd["errors"].set_title(f"Errors history {titles[i]}")

        plt.tight_layout()

    axd_pos[pos_layout[0][0]].plot(times, (np.array(targets)[:, 0]), "--", linewidth=3)

    axd_pos[pos_layout[1][0]].plot(times, (np.array(targets)[:, 1]), "--", linewidth=3)

    axd_pos[pos_layout[2][0]].plot(times, (np.array(targets)[:, 2]), "--", linewidth=3)

    fig_pos.legend([*titles, "Target"], loc=(0.25, 0), ncol=4)
    plt.show()


if __name__ == "__main__":
    main()
